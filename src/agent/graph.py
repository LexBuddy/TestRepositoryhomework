# -*- coding: utf-8 -*-
"""Copy of legal_agentUpdate.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Ycx2z6fFQK2g7ndDlsbCgXPnXaf4wkP_
"""



from dotenv import load_dotenv
import os

# Cargar variables desde el archivo .env
load_dotenv()

# Acceder a las variables de entorno
openai_api_key = os.getenv("OPENAI_API_KEY")
langchain_tracing_v2 = os.getenv("LANGCHAIN_TRACING_V2")
langchain_endpoint = os.getenv("LANGCHAIN_ENDPOINT")
langchain_api_key = os.getenv("LANGCHAIN_API_KEY")
langchain_project = os.getenv("LANGCHAIN_PROJECT")

import os
import uuid
from typing import Annotated, Optional, Literal
from typing_extensions import TypedDict

from langchain_core.runnables import Runnable, RunnableConfig
from langchain_core.prompts import ChatPromptTemplate
from langchain_openai import ChatOpenAI
from langchain_core.tools import tool
from langgraph.graph import StateGraph, START, END
from langgraph.graph.message import AnyMessage, add_messages
from langgraph.prebuilt import tools_condition
from langgraph.prebuilt.tool_node import ToolNode
from langchain_core.messages import AIMessage, HumanMessage, ToolMessage
from datetime import datetime


"""## DB Definition"""

import sqlite3
conn = sqlite3.connect("legal_cases.db", check_same_thread=False)  # Creates the file if it doesn't exist
cursor = conn.cursor()

"""- id del caso
- nombre /titulo del caso
- descripción del caso
- autor del caso
- fecha de creación
"""

cursor.execute(
    """
    CREATE TABLE IF NOT EXISTS cases (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        description TEXT NOT NULL,
        author TEXT NOT NULL,
        creation_date DATE NOT NULL
    )
    """
)

conn.commit()

res = cursor.execute(
    """
    SELECT * FROM cases;
    """
)

print(res)

conn.commit()

"""# Definitions"""

def update_current_agent_stack(left: list[str], right: Optional[str]) -> list[str]:
  """Pusth or pop the state"""
  if right is None:
    return left

  if right == "pop":
    return left[:-1]

  return left + [right]

"""## State definition"""

class State(TypedDict):
    messages: Annotated[list[AnyMessage], add_messages]

    user_info: str

    current_date: str

    current_agent: Annotated[list[Literal[
        "query_generator",
        "legal_assistant",
        "router"
    ]], update_current_agent_stack]

"""{
  "messages": ,
  "user_info": ,
  "current_agnt":
}

## Agents
"""

class Assistant:
    def __init__(self, runnable: Runnable):
        self.runnable = runnable

    def __call__(self, state: State, config: RunnableConfig):
        state = {**state}
        result = self.runnable.invoke(state)
        return {"messages": result}

"""## First agent

GOAL:
- Crear casos
- Eliminar casos
- Actualizar casos
- Obtener casos

ESQUEMA DE BASE DE DATOS:
- id del caso
- nombre /titulo del caso
- descripción del caso
- autor del caso
- fecha de creación
"""

from pydantic import BaseModel, Field

# ROUTING TOOLS
class ToCompanyCases(BaseModel):
  """This tool transfers work to a an agent that has access to company cases whether to create, update or retrieve."""
  # docsstring in langgraph work to add CONTEXT to the llm

  intention_command: str = Field(description="The main command that will be executed in the query")
  intention_summary: str = Field(description="The intention summary the user has for the query")

class ToLegalAssistant(BaseModel):
  """This tool transfers work to a legal expert agent"""

  question_summary: str = Field(description="The user's question summary")


class CompleteOrEscalate(BaseModel):
  """This tool marks the current task as completed and/or to escalate control over the main agent that'll handle the users intent. This main agent will re-route the intent based on user needs."""

  reason: str = Field(description="The user's reason of completion or escalation")
  cancel: bool = True

class CreateLegalCase(BaseModel):
  name: str = Field(description="Legal case name")
  description: str = Field(description="Legal case detailed description")

class UpdateLegalCase(BaseModel):
  id: Optional[int] = Field(None, description="Identificador Unico de el caso legal para ser actualizado")
  name: Optional[str] =  Field(None, description="Nuevo nombre para el caso legal, si se quiere actualizar")
  description: Optional[str] = Field(None, description="Descripcion detallada para el caso legal, si se quiere actualizar")

class DeleteLegalCase(BaseModel):
  id: Optional[int] = Field(None, description="Identificador Unico de el caso legal para ser borrado")

"""## database schemas

## tools
"""

def execute_sql_query(query, params=None):
    if params:
        cursor.execute(query, params)
    else:
        cursor.execute(query)
    rows = cursor.fetchall()
    return rows

@tool
def select_cases(sql_query: str):
  """seleccionar los casos de la tabla dependiendo de la solicitud del usuario con o sin filtros cuando se retorne ten en cuenta de mostrar tambien el id en la respuesta
    si la query se ejecuto correctamente mencionalo
  """
  results = execute_sql_query(sql_query)

  return results


@tool
def create_case(input_case: CreateLegalCase,  state: State):
    """Crea un nuevo caso legal basado en los datos proporcionados por el usuario."""

    author = state["user_info"]
    creation_date = datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S')


    create_query = f"""
        INSERT INTO cases (name, description, author, creation_date)
        VALUES ('{input_case.name}', '{input_case.description}', '{author}', '{creation_date}');
    """

    results = execute_sql_query(create_query)
    return results


@tool
def update_cases(update_case_data: UpdateLegalCase):
    """
    Actualiza un caso legal en la base de datos. Solo se actualizan los campos proporcionados.
    Es necesario pasar el ID del caso.
    """
    id = update_case_data.id
    name = update_case_data.name
    description = update_case_data.description

    if id is None:
        return "Por favor selecciona primero el caso que deseas actualizar."


    case_exist = execute_sql_query(f"SELECT id FROM cases WHERE id = {id};")
    if not case_exist:
        return f"El caso con ID {id} no existe."

    updates = []

    if name:
        updates.append(f"name = '{name}'")
    if description:
        updates.append(f"description = '{description}'")

    if not updates:
        return "No se proporcionaron nuevos valores para actualizar."

    query = f"UPDATE cases SET {', '.join(updates)} WHERE id = {id};"

    try:
        execute_sql_query(query)
        return f"Caso con ID {id} actualizado correctamente"
    except Exception as e:
        return f"Ocurrió un error al intentar actualizar el caso: {str(e)}"



@tool
def delete_cases(delete_case_data: DeleteLegalCase):
    """
    Elimina un caso legal de la base de datos, si existe.
    Primero valida que se haya proporcionado un ID y luego verifica que el caso exista antes de eliminarlo.
    """
    id = delete_case_data.id

    if id is None:
        return "Por favor selecciona el caso que deseas borrar. Pregunta para conocer qué casos existen para identificarlo."


    check_query = f"SELECT id FROM cases WHERE id = {id};"
    case_exist = execute_sql_query(check_query)

    if not case_exist:
        return f"El caso con ID {id} no existe. No se puede eliminar."


    delete_query = f"DELETE FROM cases WHERE id = {id};"

    try:
        execute_sql_query(delete_query)
        return f"Caso con ID {id} eliminado correctamente."
    except Exception as e:
        return f"Ocurrió un error al intentar eliminar el caso: {str(e)}"

"""## helpers"""

from typing import Callable
from langchain_core.messages import ToolMessage

def create_entry_node(assistant_name: str, current_agent: str) -> Callable:
  def entry_node(state: State) -> dict:
    tool_call_id = state["messages"][-1].tool_calls[0]["id"]
    return {
      "messages": [
          ToolMessage(
            tool_call_id=tool_call_id,
            content=f'You are now the {assistant_name}. Reflect on the above conversation and continue with the users intent'
        )
      ],
      "current_agent": current_agent
    }

  return entry_node

def pop_current_agent(state: State) -> dict:
  """This function pops the current agent value and returns to the previous one or main assistant."""
  messages = []
  if state["messages"][-1].tool_calls:
    tool_call_id = state["messages"][-1].tool_calls[0]["id"]
    messages.append(
        ToolMessage(
            tool_call_id=tool_call_id,
            content="Resume conversation with the main assistant. Reflect on the above conversation and assist the user with their needs."
        )
    )

  return {
      "current_agent": "pop",
      "messages": messages
  }

"""### ESTE PROCESO DE ABSTRACCIÓN DE PASAR DE UN TEXTO 'GENÉRICO' A ALGO MÁS SINTETIZADO Y ESTRUCTURADO
# NO SOLO LO HACEN LOS AGENTES, SINO TAMBIÉN LOS ABOGADOS.


### USER MESSAGE AL AGENTE
'''
no te entregué la tarea 1 (qué no te entregué)
porque tuve un problema personal con mi familia (porqué no la entregué)
quisiera que me la aceptara con una calificación menor
se la puedo entregar hoy por la tarde (propuesta de solución)
'''

### AGENT INTEPRETATION OF THE MESSAGE
class ToQueryGenerator(BaseModel):
  '''This tool explains the teacher why i couldn't deliver the homework'''
  homework: str = Field(description="the homework i'm refering to")
  reason_i_didnot_deliver: str = Field(description="the reason i could not deliver the homework")
  final_action_proposal: str = Field(description="the final action i propose to the teacher")
"""

llm = ChatOpenAI(model="gpt-4o-mini")

agent_route_prompt = ChatPromptTemplate.from_messages(
    [
        ("system", """#MAIN GOAL
        Eres un agente experto en temas legales que ayuda al despacho
        a consultar sus casos existentes y responder con información legal relevante"""),

        ("system", """#BEHAVIOUR
        Tú trabajo es enrutar y dirigir al usuario al caso que mejor corresponda con su necesidad.
        Se muy objetivo y haz preguntas de seguimiento en caso de que sea necesario para darle la mejor
        experiencia.

        Este es el usuario actual: {user_info}
        Esta es la fecha actual: {current_date}
        """),

        ("placeholder", "{messages}")
    ]
)

# we define the route agent with tools for routing
agent_route_runnable = agent_route_prompt | llm.bind_tools([ToCompanyCases, ToLegalAssistant])

llm = ChatOpenAI(model="gpt-4o-mini")

legal_assistant = ChatPromptTemplate.from_messages(
    [
        ("system", """
        Eres un experto legal en México con conocimiento de leyes a profunidiad.
        NO CONTESTES NADA FUERA DE TU ALCANCE LEGAL.

        Este es el usuario actual: {user_info}
        Esta es la fecha actual: {current_date}
        """),
        ("placeholder", "{messages}")
    ]
)

# we define an sql query generator agent.
legal_assistant_runnable = legal_assistant | llm.bind_tools([CompleteOrEscalate])

llm = ChatOpenAI(model="gpt-4o-mini")

sql_query_generator = ChatPromptTemplate.from_messages(
    [
        ("system", """
        Tienes acceso a todos los casos existentes dentro del despacho. Tu trabajo es crear queries de SQL que resuelvan las preguntas de negocio
        conectándose a la base de datos del despacho y actúa con base en las necesidades del usuario, por otro lado tienes tools como para actualizar asi
        como para borrar casos.

        This is the db schema:
          - id INTEGER PRIMARY KEY AUTOINCREMENT,
          - name TEXT NOT NULL,
          - description TEXT NOT NULL,
          - author TEXT NOT NULL,
          - creation_date DATE NOT NULL

        Este es el usuario actual: {user_info}
        Esta es la fecha actual: {current_date}

        """),
        ("placeholder", "{messages}")
    ]
)

cases_tools = [create_case, select_cases, update_cases, delete_cases]

# we define an sql query generator agent.
sql_query_generator_runnable = sql_query_generator | llm.bind_tools(cases_tools + [CompleteOrEscalate])

"""# GRAPH"""

from typing import Literal

def initial_node(state: State):
  return {"user_info": "emanuel"}

graph = StateGraph(State)

# Fetch user data
graph.add_node("fetch_user", initial_node)

# Router node - "initial" node
graph.add_node("router", Assistant(agent_route_runnable))

# Leave node - handle escalation
graph.add_node("leave_agent", pop_current_agent)

# SQL Agent
graph.add_node("query_generator", Assistant(sql_query_generator_runnable))
graph.add_node("ToCompanyCases", create_entry_node("Company Cases Assistant", "query_generator"))

graph.add_node("sql_tools", ToolNode([select_cases, create_case, update_cases, delete_cases]))

graph.add_edge("sql_tools", "query_generator")

# Legal expert agent
graph.add_node("legal_assistant", Assistant(legal_assistant_runnable))
graph.add_node("ToLegalAssistant", create_entry_node("Legal Assistant", "legal_assistant"))

# Temporal agent routing
graph.add_edge("ToCompanyCases", "query_generator")
graph.add_edge("ToLegalAssistant", "legal_assistant")
graph.add_edge("leave_agent", "router")



def initial_routing(state: State) -> Literal["router", "query_generator", "legal_assistant"]:
  """Evaluate current state agent"""

  current_agent = state.get("current_agent")
  print(current_agent)

  if not current_agent:
    return "router"

  return current_agent[-1]


def intitial_route_function(state: State) -> Literal["ToCompanyCases", "ToLegalAssistant", "__end__"]:
  tools = tools_condition(state)

  if tools == END:
    return END

  tool_calls = state["messages"][-1].tool_calls
  print(tool_calls)

  if tool_calls:
    if tool_calls[0]["name"] == ToCompanyCases.__name__:
      return "ToCompanyCases"
    if tool_calls[0]["name"] == ToLegalAssistant.__name__:
      return "ToLegalAssistant"

  return "__end__"


def legal_tool_handling(state: State) -> Literal["leave_agent", "__end__"]:
  tools = tools_condition(state)

  if tools == END:
    return END

  tool_calls = state["messages"][-1].tool_calls

  did_cancel = any(tc["name"] == CompleteOrEscalate.__name__ for tc in tool_calls)

  if did_cancel:
    return "leave_agent"

  return "__end__"



def sql_tool_handling(state: State) -> Literal["leave_agent", "sql_tools", "__end__"]:
  tools = tools_condition(state)

  if tools == END:
    return END

  tool_calls = state["messages"][-1].tool_calls
  did_cancel = any(tc["name"] == CompleteOrEscalate.__name__ for tc in tool_calls)

  if did_cancel:
    return "leave_agent"

  cases_tool_names = {tool.name for tool in cases_tools}

  if tool_calls[0]["name"] in cases_tool_names:
    return "sql_tools"

  return "__end__"


graph.add_conditional_edges("fetch_user", initial_routing)

graph.add_conditional_edges(
    "router", #nodo de inicio
    intitial_route_function, #función de enrutamiento
)

graph.add_conditional_edges("query_generator", sql_tool_handling)

graph.add_conditional_edges("legal_assistant", legal_tool_handling)

graph.set_entry_point("fetch_user")

